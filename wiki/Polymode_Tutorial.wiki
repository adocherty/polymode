#summary Tutorials for the Polymode Microstuctured Optical Fiber Solver

http://polymode.googlecode.com/svn/misc/images/polymode2.png

<wiki:toc max_depth="3" />

== Running the tutorials ==
In the directory named “tutorials” which contains a number of test programs that use the Polymode code.
After installing Polymode you can move this folder anywhere you wish, and run your own code using Polymode from any directory.

The *IPython* interactive python shell is assumed throughout this tutorial, although they
can be run directly using python non-interactively as well.
To run these examples open the IPython shell and cd to this directory.

{{{
cd _tutorial directory_
}}}

Run the  program (in this case named “ex1_materials.py”) typing:

{{{
run _name of file_
}}}

You can include the “.py” extension but it is not necessary.

These examples don't assume any familiarity with the Python programming language, however
for more advanced usage it is useful to have some knowledge of programming in it. A good
introduction to Python programming is available at the [http://docs.python.org/tutorial/index.htm Python tutorial]
or the [http://www.diveintopython.org/ Dive Into Python] websites.

----

== Tutorial 1 ==

=== Materials ===
At the *IPython* interactive prompt run the  program (in this case named “ex1_materials.py”) typing:

{{{
run  ex1_materials.py
}}}

You should get an output similar to this:

{{{
	PMMA Polymer
	Wavelength limits (um): 0.25->1.5
	Temperature limits (K): 0->400 
	Cite: 
	Refractive index at 1.45um is 1.48074+0i 

	Fused Silicon Oxide (SiO₂) 
	Wavelength limits (um): 0.2->3.8 
	Temperature limits (K): 0->400 
	Cite: Malitson 1965, http://www.opticsinfobase.org/abstract.cfm?URI=josa-55-10-1205 
	Refractive index at 1.45um is 1.4452+0i 

	Silica doped with Germania 
	Wavelength limits (um): 0.6->1.8 
	Temperature limits (K): 0->400 
	Cite: Sunak, H.R.D.; Bastien, S.P., Photonics Technology Letters V1 N6 142-145, 1989 
	Refractive index at 1.45um is 1.45313+0i 
}}}

The code itself is shown and explained following:

{{{
from numpy import *
from ABCSolver import *

#Basic materials 
air = Material.Air() 
m145 = Material.Fixed(1.45) 
}}}

The first two lines are needed in all programs using Polymode, they import the Polymode code for us to use and the numerical python code to enable mathematical operations on arrays.
The next two lines create two of the most common materials. `Material.Fixed` allows you to create a material
with a fixed refractive index, here 1.45, that doesn't change with wavelength.
`Material.Air` is the same as  `Material.Fixed(1)` - it gives a material with a fixed refractive index of 1.

{{{
silica = Material.Silica() 
germania = Material.Germania() 
pmma = Material.Polymer() 
}}}

These are some common materials for waveguides to be constructed from.
They have different refractive indices at different wavelengths which is automatically calculated.

{{{
sige = Material.SiO2GeO2(0.05) 
}}}

The inbuilt material SiO2GeO2, Silica doped with Germania , has a higher refractive index than silica and is used for the core of optical fibers. This approximation is accurate for a dopant concentration up to about 20%.

{{{
wl = 1.45

for mat in [pmma, silica, sige]: 
	ri = mat.index(wl) 
	mat.info() 
	print "Refractive index at %gum is %.6g+%.4gi\n" \
			% (wl, real(ri), imag(ri))
}}}

Here we iterate over the materials pmma, silica and sige and print their refractive index at a wavelength wl in micrometers.
You can get some information about the material, including a reference for where the data is derived using the `.info()` method for any material.
You are now at a command prompt for python and can enter commands and explore the materials that have been defined.
Try plotting the refractive index of polymer versus the wavelength by typing the command `pmma.plot()`

_Note that you may need the draw() command to refresh the plot window_

http://polymode.googlecode.com/svn/wiki/figures/fig1_materials.png

=== The Waveguide ===
To construct an optical fiber we now need to create a waveguide and put different materials in it.
Try running the example, it should plot the waveguide and look like this:

http://polymode.googlecode.com/svn/wiki/figures/fig2_waveguide.png

The different colors represent different materials, here the green is the doped core and the surrounding grey the undoped silica.

Let’s see how this has been done, by looking at the code of `ex1_the_waveguide.py`.
There are three parts to creating the waveguide: choosing the waveguide parameters and materials, and then assembling the waveguide structure by placing particular shapes into it. 

{{{
wg = Waveguide.Waveguide(material=cladding, symmetry=1) 
}}}

*Material*: The material that comprises the waveguide substrate.

*Symmetry*: To make the program more efficient we can exploit the rotational symmetry of the fiber. For example, if the waveguide has six identical sectors we only need to solve in a 60 degree segment and the symmetry is 6. A completely asymmetric structure would have a symmetry of 1. Lower symmetries are much slower to calculate.

{{{
s1 = Waveguide.Circle(core, center=(0,0), radius=2.0) 
wg.add_shape(s1) 
}}}

A waveguide needs to have some shapes added to it. There are a number of shaped available in the Waveguide module. The first parameter in any shape is the material it is made from, then there are different parameters for each shape type.

In this case we add the core as a circle at the origin with a radius of 2 μm. To plot the waveguide we now use the command:

{{{
wg.plot()
}}}

Note: to plot the refractive index profile that will be used in the solver code you can use this command `wg.plot_bitmap(Nx)`

== Tutorial 2 ==

=== Finding Modes of a Step Index Fiber ===

This exercise takes the waveguide constructed in the preceding problem and solves for 5 modes in it.

Running the code by the command `run ex2_step_index_modes`.
Will construct the waveguide and solve for three modes giving the following output from the mode solver,
as the modes are solved:

{{{
	I: Mode #0 [13:1.11s] neff:1.46319 + 1.19e-18i res: 6.926e-12 
	I: Mode #1 [12:1.01s] neff:1.46303 + 6.18e-19i res: 1.297e-13 
	I: Mode #0 [12:1.08s] neff:1.47428 - 6.20e-18i res: 6.762e-12 
}}}

The information printed during the solving process gives information on the current mode found:

{{{
Mode #number [iterations], neff=(effective index), res: approx error
}}}

The iterations information is how many iterations is needed to refine the leakage loss of the mode to the stated accuracy; highly leaky modes require more iterations. The value of the residue gives an indication of the accuracy of the modes - clearly neff should not be quoted to more significant figures than indicated the residue.

The code of `ex2_step_index_modes` is the same as the previous example for creating the waveguide, the only changes are the addition of the mode calculation:

{{{
Nx = 100,1	 number of radial & azimuthal points 
wl = 1.0	 wavelength 

solver = NLSolver.DefaultSolver(Nx, wg, modetype='bound') 
modes = solver(0, wl, number=2) 
modes += solver(1, wl, number=1) 
}}}

To solve for modes in our created waveguide we need to give the resolution of the numerical solution Nx. This is two numbers the first is the number of points in the radial direction and the second the number points in the azimuthal (ɸ) direction.

Note that the number of radial and azimuthal points defines the resolution of the calculation. Increasing the number of radial points linearly increases the time taken for the calculation, but the increase in calculation time as you increase the azimuthal resolution is much more dramatic. That is unfortunate as features like thin bridges with require a lot of points to resolve them properly. You should always check for proper convergence of the solution by running at different resolutions (for example, doubling the number of points). You need to be even more careful about convergence when considering the imaginary part of neff.

The solver object is created with the number of points and the waveguide as arguments. This solver can then be used to calculate any number of modes calling it with the wavenumber and  the symmetry class.

The modes are returned as a list, if we just type `modes` and hit enter the modes in the list are printed.

Any mode in the list can be inspected interactively, let's investigate the first mode. It has some properties, the effective index, the loss, the symmetry class, the wavelength. To go through each mode and print information on it we use this command:

{{{
for mode in modes: 
	mode.info()
}}}

The output is:

{{{
	VectorMode size: (100, 1), symmetry=1, m0=0, λ=1, rmax=2.1, vecs: RL {} 
	 | neff=1.46319 + 6.10e-19i 	loss=3.327e-11dB/m 	res=2.58e-13 
	 | Effective Area: 10.111 μm² 
	 | Spot size: 0.4035 μm 
	 | Numerical Aperture: 0.1747 

	VectorMode size: (100, 1), symmetry=1, m0=0, λ=1, rmax=2.1, vecs: RL {} 
	 | neff=1.46303 - 4.34e-19i 	loss=-2.368e-11dB/m 	res=1.47e-13 
	 | Effective Area: 10.076 μm² 
	 | Spot size: 0.3979 μm 
	 | Numerical Aperture: 0.175 

	VectorMode size: (100, 1), symmetry=1, m0=1, λ=1, rmax=2.1, vecs: RL {} 
	 | neff=1.47428 - 7.99e-19i 	loss=-4.358e-11dB/m 	res=4.78e-12 
	 | Effective Area: 5.7825 μm² 
	 | Spot size: 0.7165 μm 
	 | Numerical Aperture: 0.22842 
}}}

=== Leaky Modes of a Step Index Fiber ===

Run this tutorial as usual by `run ex2_leaky_modes`.
This should print the list of found modes like the previous tutorial and then plot them. 

{{{
	I: Mode #0 [13:1.04s] neff:1.46314 + 7.89e-04i res: 4.622e-12 
	I: Mode #1 [12:1.12s] neff:1.46301 + 8.07e-04i res: 5.601e-14 
	I: Mode #0 [12:1.08s] neff:1.47439 + 1.69e-04i res: 1.017e-11 
}}}

Look at this program file, the program is the same as the previous apart from the waveguide now has a substrate of polymer and an annlus of air that forms the cladding. Plot the refractive index profile of the waveguide:

{{{
wg.plot_bitmap(Nx)
}}}

This structure gives rise to modes that are guided by the core and cladding, but energy from them can tunnel through the this air gap and this causes leakage loss.

This loss can be modelled by the program. In the solver we specify we want to look for outward going modes (bound modes are not supported in this structure).

{{{
solver = NLSolver.DefaultSolver(Nx, wg, modetype='outward') 
modes = solver(0, wl, number=2) 
modes += solver(1, wl, number=1) 
}}}

We find modes in symmetry classes 0 and 1 just as previously. However the modes will now be lossy. The loss of each mode can be shown using the info() function:

{{{
modes[0].info() 

	VectorMode size: (100, 1), symmetry=1, m0=0, λ=1, rmax=3.15, vecs: RL {} 
	 | neff=1.46314 + 7.89e-04i 	loss=4.305e+04dB/m 	res=4.62e-12 
	 | Effective Area: 10.618 μm² 
	 | Spot size: 0.73925 μm 
	 | Numerical Aperture: 0.17061
}}}

You can also find the loss directly using the loss property of the mode:

{{{
modes[0].loss 
>> 43052.327880062359 
}}}

The entire mode list is now plotted with the commands:

{{{Plotter.plot_modes_in_grid(modes, rmax=5) }}}

To plot a single mode we can use the command:

{{{modes[mode number].plot()}}}

Where the mode number is a number from `0` to `number of modes – 1`.

The plot will default to plotting the power, or precisely the z-component of the time-averaged Poynting vector. However other parts of the electromagnetic field can also be plotted. For example the command
`modes[0].plot('Hr')`
plots the radial component of the magnetic fieldof the first mode. 

Other parts of the electromagnetic field that can be plotted are:
`'Sz', 'Hr', 'Ha', 'Er', 'Ea', 'Hz', 'Ez', 'Hx', 'Hy', 'Ex', 'Ey'`
where 'Sz' is the z-component of the Poynting vector.

Also `'pe', 'ph'` will plot the electric and magnetic polarisation vectors. If the mode is elliptically or circularly polarised this polarisation plots will be elliptical.

This example used the save_data and load_data commands to save calculated modes and load them back again to plot them. They can be used to save any objects you like including waveguides, materials, shapes and modes.

{{{
save_data(data, filename)
data = load_data(filename)
}}}

Try running the next file `ex2_plotting_modes.py` to see some commands in action.

== Tutorial 3 ==

=== Microstructured fibers ===
A microstructured fiber can be created in the same way as the fibers we have created so far, however we will now have much more flexibility of what shapes to create in the waveguide.
Initially let's create a waveguide from PMMA polymer with six circular airholes. The structure we want looks like this:

http://polymode.googlecode.com/svn/wiki/figures/fig3_sixholes.png

The waveguide can be created in the same way, but now we use the fact that it is six-fold symmetric and set the symmetry to be six. We then only need to add one circule and the rest will be created automatically by the symmetry. The code to do this is:

{{{
air = Material.Air() 
polymer = Material.Polymer() 
wg = Waveguide.Waveguide(material=polymer, symmetry=6) 
s1 = Waveguide.Circle(air, center=(3,pi/6), radius=1.25) 
wg.add_shapes(s1) 
wg.plot()
}}}

There are many other shapes that can be used to create different geometries. Some of them with their options are:

 * Waveguide.Circle( material, center=(r,,0,,, ɸ,,0,,), radius=radius, zorder=0, xy=False) 
 * Waveguide.Ellipse( material, center=(r,,0,,, ɸ,,0,,), axes=(a,b), rot=0, sampling=100, zorder=0, xy=False) 
 * Waveguide.Rectangle( material, center=(r,,0,,, ɸ,,0,,), axes=(a,b), rot=0, zorder=0, xy=False)
 * Waveguide.Polygon( material, nodes=[ list of node coords ],  zorder=0, xy=False)
 * Waveguide.Annulus( material,  r=(r,,min,,, r,,max,,, phi=(ɸ,,min,,, ɸ,,max,,), zorder=0)
 * Waveguide.Image( material, image=None, border=0)

The axes parameters for the ellipse and rectangle set the width and height of the objects relative to the coordinate system. They will be aligned along the radial and polar directions by default, however giving an argument to `rot` will change this.

It is important  to note that the coordinate system defaults to polar, however setting the option xy to True enables the center to be given in cartesian coordinates and the axes to line up with the cartesian directions.

=== Solving Modes in Microstructured Fibers ===
We now want to find some modes in the previous fiber geometry. As before we create a solver object and run the solver with different symmetry indices to get different classes of modes. Note that the symmetry index with a fiber of symmetry N will range from -N/2 … N/2 and the modes for negative and positive indices are degenerate. We will come back to this point.

The code to solve for modes in the waveguide in `ex3_finding_modes.py`is:

{{{
Nx = 100,11
wl = 1.45

solver = NLSolver.DefaultSolver(Nx, wg) 
modes = solver(0, wl, number=2) 
modes += solver(1, wl, number=3) 

save_data((modes, wg), "ex3_modes.dat") 
Plotter.plot_modes_in_grid(modes) 
}}}

We now specify the number of radial and azimuthal points, generally the azimuthal number should be odd. We solver for 2 modes with a symmetry index of 0 and three for a symmetry index of 1.
The modes as well as the waveguide are saved to the file 'ex3_modes.dat', note the use of brackets to group them together.
The modes are plotted in a grid as before.

http://polymode.googlecode.com/svn/wiki/figures/fig4_modes.png

=== More Plotting of Modes ===

There are many ways to plot the modes found. Using the `Plotter.plot_modes_in_grid` also takes a plottype of the same kind as the individual mode plotting namely `'Sz', 'Hr', 'Ha', 'Er', 'Ea', 'Hz', 'Ez', 'Hx', 'Hy', 'Ex', 'Ey','pe', 'ph'`.

Issuing two different plot commands succesively will plot one plot over another, as shown in  `ex3_plotting_modes.py`:

{{{
#Plot the poynting vector and the H-polarization
Plotter.plot_modes_in_grid(modes, plottype='sz')
Plotter.plot_modes_in_grid(modes, plottype='ph', title='number')
}}}

The z-component of the electric and magnetic field is calculated from the transverse components,
therefore to calculate the z-component of the electric field the waveguide needs to be specified.

{{{
#Select the second mode
m = modes[0]

#Plot Ez in a cartesian grid. Note that the waveguide is required to calculate Ez
subplot(121)
m.plot('ez', cartesian=1, rmax=10, wg=wg)
colorbar()					#A color bar gives the valueof the colors
wg.plot(fill=0)				#Plot an outline of the waveguide on top

#Now plot Hz in the same way. We don't need the waveguide for this
subplot(122)
m.plot('hz', cartesian=1, rmax=10)
colorbar()					#A color bar gives the valueof the colors
wg.plot(fill=0)				#Plot an outline of the waveguide on top
}}}

Here we also plot the modes in caresian coordinates using the `cartesian` flag.

Documentation for general plotting commands can be found at http://matplotlib.sourceforge.net

=== More shapes ===
The example `ex3_more_shapes.py` creates a waveguide with three different shapes and finds the fundamental mode in it.

http://polymode.googlecode.com/svn/wiki/figures/fig5_moreshapes.png


== Tutorial 4 - More advanced waveguides ==

=== Coated holes ===

Shapes can be coated with another material of a specified thickness using the
{{{
Material.coated_shape(shape, coating material, thickness)
}}}
function. This takes a previously created shape, a coating material and a thickness and returns a shape to use as the coating. Note that any shape can be coated, not just circular inclusions.
This is seen in the `ex4_coated_holes.py` file. The relavant portion is shown here, a circle is created and coated with a material of higher refractive index and both shapes are added to the waveguide.

{{{
hole = Waveguide.Circle(air, center=(6.75,0), radius=1.5) 
coating = Waveguide.coated_shape(hole, m17, 0.2) 
wg.add_shape(hole, coating) 
}}}

The fundamental mode is found:

http://polymode.googlecode.com/svn/wiki/figures/fig6_coatedhole.png

=== Waveguide from a bitmap image ===

The second way to enter a structure is to use an image. The example folder gives images of waveguide structures this way *MOF_NRL.png*, an example taken from literature of a photonic crysal filber and and *hlfcollapsedKagome.png* a schematic of a kagome structure. Pictures of these structures are found in the directory called images. 

Images are used in a similar way to other objects. However first the bitmap must be imported using the `Image.ImportBitmap(filename, size=(sx,sy), negative=True/False)` function. 
This imports an image from the named file of a specified x and y dimentions in microns. The negative flag is false if the bright parts of the image are to be considered the material and false if the opposite is the case.
Then the waveguide shape can be created using the command `Waveguide.Image(material, image)`

The image will take a while to be converted to work with the waveguide as the image is optimized for the waveguide symmetry and converted to polar coordinates.

The code from the `ex4_waveguide_from_image.py` example file is

{{{
image = Image.ImportBitmap(os.path.join("images","MOF_NRL.png"), size=(20,20), offset=pi/6, negative=True)
image.contrast(scale=15, transition=0.45)
wg.add_shape(Waveguide.Image(air, image))
}}}

Note that the `os.path.join` function joins path names in a platform independent way so it will work on Linux and Windows. On Windows you can equivalently just write "images\MOF_NRL.png".

Other actions can be applied to the image object, it may be necessary to apply some contrast to the image, in this case we adjust the contrast by changing the amount of contrast (scale) and the relative light/dark bias (transition).

Also a new way to plot the waveguide is given, the plot_bitmap command gives the actual numerical values of the waveguide on a polar grid of 200x60 pixels (in this case), the sectors=1 specified plotting just one of the symmetric sectors and the cmap command chooses the colormap.

{{{
wg.plot_bitmap((200,60), sectors=1, cmap=Plotter.cm.gray)
}}}

http://polymode.googlecode.com/svn/wiki/figures/fig7_image.png

=== Merging Shapes ===

If shapes created in the waveguide overlap then they are automatically merged and one will override the other, appearing "in front" of the other. This behaviour can be changed with the shape property `zorder` - this defaults to 0 and the higher zorders appear in front of the lower zorders.

The code of  `ex4_merging_shapes.py` specifies the `zorder` of an shape using the `zorder=1` argument when creating the shape, and then changes the orders directly accessing the `shape.zorder` property.

{{{
s0 = Waveguide.Ellipse(m2, center=(0,0), axes=(3.0,1.5))
s1 = Waveguide.Circle(air, center=(3,pi/6), radius=1.5, zorder=1)
wg.add_shapes(s0, s1)

Plotter.subplot(121)
wg.plot_bitmap(Nx)

#Change orders around
s0.zorder=1
s1.zorder=0

Plotter.subplot(122)
wg.plot_bitmap(Nx)
}}}

The waveguide on the left should have the blue circles in front of the red ellipses.

http://polymode.googlecode.com/svn/wiki/figures/fig8_mergeshapes.png

=== Refractive index profiles ===
A non-step dependence on the refractive index of any shape can easily be defined. 
The file `ex4_parabolic_index.py` creates a circular core and assignes it a parabolic refractive index.
A refractive index profile can be specified as a function of the distance from the objects center.

{{{fn_parabolic = lambda d: 1-(d/radius)**2 }}}

This uses a Python “lambda function” to specify a function of d, distance. The function should be normalized to 0 and 1, a value of 1 will be assigned the refractive index of the object and 0 will be assigned the refractive index of the background. The defined function is 1 at the center of the circle and 0 at the edge.
radius = 4 

{{{
## Materials 
si = Material.Silica() 
ge = Material.Germanium() 
sige = Material.Composite(materials=[si, ge], weights=[0.98,0.02]) 

## Create waveguide 
wg = Waveguide.Waveguide(rmax=8, material=si, symmetry=2) 

## Parabolic index profile based on distance from center of object 
fn_parabolic = lambda d: 1-(d/radius)**2 

## Doped core 
s1 = Waveguide.Circle(sige, center=(0,0), radius=radius) 
s1.index_function = fn_parabolic 

wg.add_shape(s1) 

Nx = 500,1 
k = 2*pi/1.0 

wg.plot_bitmap(Nx, k0=k) 
}}}

The output of this example is shown below, the refractive index of Silica (1.4504) and Silica doped with 20% Germania (1.482) at a wavelength of λ=1.0μm is also plotted.

http://polymode.googlecode.com/svn/wiki/figures/fig9_parabolic.png

=== Solving modes in an image waveguide ===

Here we use another image load it and solver 4 modes in it. The image does not have rotational symmetry so we
specify `symmetry=1`. The image is given a specified center as the automatic center calculation doesn't work without rotational symmetry. 

{{{
# Create waveguide and specify the problem domain to have radius 15
wg = Waveguide.Waveguide(rmax=15, material=polymer, interior=polymer, symmetry=1)

# Load a png file and specify the size of the original image
# The center of the image (pixel offset) must also be specified for symmetry=1
image = Image.ImportBitmap("images/celery.png", size=(60,120), center=(230,140), negative=True)

# Add the shape to the waveguide
wg.add_shape(Waveguide.Image(air, image, border=2))

# Waveguide Parameters:
Nx=100,81		#number of radial & azimuthal points
wl=1.55			#Wavelength

# Create the solver
solver = NLSolver.DefaultSolver(Nx, wg)
modes = solver(0, wl, number=4)

Plotter.plot_modes_in_grid(modes)
}}}

Note the `interior=polymer` is only typically needed for an image waveguide as the code cannot determine what the material of the core is. If the core material or material outside the calculation range (beyond rmax) is different from the waveguide's material then it needs to be specified:

{{{
Waveguide.Waveguide(material=_material_, interior=_material_, exterior=_material_)
}}}

Loading an image only allows you to have two different materials in the waveguide - the waveguide itself and the material assigned to the image. However, it is possible to add mode shapes to the waveguide on top of the image with different materials, even other images.

Be aware that using waveguides without symmetry will be very slow to solve for modes as the number of azimuthal points needed is large.

http://polymode.googlecode.com/svn/wiki/figures/fig_imagemodes.png

== Tutorial 5 - Advanced solving ===

=== Mode Quantities ===
This tutorial file is `ex5_modal_quantities.py`.

The `mode` object has a lot of information about the mode. The basic properties are:
 * The wavelength
 * The loss
 * The symmetry class
 * The propagation constant
 * The effective index

Other quantities can be calculated from the 
 * Group index
 * Proportion of power in the core
 * Spot size
 * Nonlinear effective area, A,,eff,,

Some of these are accessed in the tutorial file
{{{
for m in modes:
	m.normalize(by='ext')

	print
	print "Mode effective index:", m.neff
	print "Loss: %.3g dB" % m.loss
	print "Symmetry class:", m.m0
	print "Propagation constant:", m.beta
	print "Wavelength:", m.wavelength

	print "Group index:", m.group_index(wg)
	print "Propagation contant from integral:", m.integral_propagation_lossless(wg)
	print "Proportion of power in core:", real(m.mode_power(r=wg.guess_core_size())/m.mode_power())
}}}

=== Convergence ===
This tutorial file is `ex5_convergence_test.py`

It can be useful to check the accuracy of the calculated effective index or other modal properties. This can be done by running the solver with different numbers of points. The file `ex5_convergence_test.py` does just that, and presents the results.

Here instead of creating a solver and the running it immediately we create the solver and initialize it with the same arguments we would use to solve for the modes we want and then add the solver to a list.

This list of solvers is given to the `batch_solve` function which solves them sequentially, and writes the intermediate results to the filename specified. This means that if the calculation is interrupted then the results to that point can still be recovered.

{{{
wl = 1.45
Naz = 41
solvers = []
for Nr in [50,100,200,400,800]:
	solver = NLSolver.DefaultSolver((Nr,Naz), wg)
	solver.initialize(1, wl, 1.45, number=1)
	solvers.append(solver)

modes = Solver.batch_solve(solvers, filename="convergencerun.solve")
}}}


{{{
#Extract neff and Nr
Nrs = [m.shape[0] for m in modes]
neff = [m.neff for m in modes]
}}}

To plot the convergence we use the most accurate run as an approximate to the true solution and plot the convergence versus the number of radial points. Python list syntax is used here, the basics are that the members of a list can be accessed using square brackets. If `x` is the list created by the command

{{{
x = [1,2,3,4]
}}}

Then `x[n]` will access the _n_th element of the list, and if `n=-1` the _last_ element is returned. So `x[0]` will return 1 and `x[-1]` will return 4. Sublists can be returned using a _slice_

{{{
x[start:end:step]
}}}

which returns a new list composed of all elements from _start_ to _end_ in increments of _step_ - not including the element at _end_. So `x[1:-1]` is all elements in the list except the first and last, `[2,3]` in this case.
More information is available here  http://diveintopython.org/native_data_types/lists.html

The approximate error in the effective indices (except the final one used as an estimate to the true solution) are now plotted against the number of radial points with red circles 'ro'.

{{{
plot(Nrs[:-1], abs(neff [:-1] - neff[-1]), 'ro')
loglog()
xlabel(r'$N_r$')
ylabel(r'Error in $n_{eff}$')
}}}

We then change the axes to be logarithmic and put some labels on the axes. Note the use of latex in the axis labels.

http://polymode.googlecode.com/svn/wiki/figures/fig10_convergence.png

=== Eliptical polarization and degenerate modes ===
This tutorial file is `ex5_uranus_fiber.py`.

This tutorial calculates the modes in a three-fold symmetric fiber from the paper by 
[http://www.opticsinfobase.org/oe/abstract.cfm?URI=oe-12-12-2795 Uranus and Hoekstra].
The waveguide is constructed of a single annulus with a span of 108 degrees. Note we convert
this to radians for the `Waveguide.Annulus` shape.

{{{
r1 = 1
r2 = 2
Daz = 108*pi/180
ring = Waveguide.Annulus(air, r=(r1,r2), phi=(-Daz/2,Daz/2))
wg = Waveguide.Waveguide(material=silica, symmetry=3)
wg.add_shape( ring )
}}}

We then find modes near the effective index 1.4 in mode classes 0 and 1. The modes and the electric polarization
are then plotted in a grid. Note we have sorted the modes in reverse order. Compare the effective indices to the modes in the Uranus paper. Increasing the resolution should improve the fit to the published effective indices.

{{{
vwe = NLSolver.DefaultSolver(Nx, wg)
modes = vwe(0, wl, 1.4, number=2)
modes += vwe(1, wl, 1.4, number=2)

modes.sort(reverse=True)

Plotter.plot_modes_in_grid(modes, 'sz,pe')
}}}

http://polymode.googlecode.com/svn/wiki/figures/fig11_uranusmodes.png

The modes in mode class 0 are linearly polarized however those in mode class 1 have a circular polarization. This is due to the fact that the solver finds both degenerate modes - compare to figure 5 in Uranus and notice that the modes with circular polarization in the above figure correspond to the degenerate mode pairs `HE11(a,b)` and `HE21(a,b)`.

We'll look at extracting two degenerate linearly polarized modes from a circularly polarized mode in the next tutorial.

=== Solving over a wavelength range ===
This tutorial file is `ex5_uranus_wavelength.py`

The wavelength properties of a mode or modes can be evaluated by calculating the mode over a range of wavelengths. The example does this with the same waveguide as the previous example. Compare this to Fig 7 of the Uranus paper.

{{{
#Create solver instances for each wavelength in a range
wlrange = arange(0.6,1.7,0.1)
solvers = []
for wl in wlrange:
	solve = NLSolver.DefaultSolver(Nx, wg)
	solve.initialize(m0, wl, 1.42, number=1)
	solvers += [ solve ]

#Use this function to solve multiple solver objects (with different parameters)
modes = Solver.batch_solve(solvers)
}}}

Any odd modes found that aren't what we are looking for are discarded using the filter function and a _lambda_ function.

{{{
#Discard spurious modes that have too large a loss
modes = filter(lambda m: m.loss<5000, modes)

subplot(121)
Plotter.plot_parameters(modes, 'neff', 'wl', style='r.')
subplot(122)
Plotter.plot_parameters(modes, 'loss', 'wl', style='r.')
}}}

Finally the effective index and loss of the modes versus the wavelength, in this case for the HE11-like mode. Try plotting the wavelength parameters for other types of modes too.

http://polymode.googlecode.com/svn/wiki/figures/fig12_uranus_wavelength.png

=== Wavelength tracking ===

== Tutorial 6 ==

=== Coordinates  ===
This tutorial file is `ex6_coordinates.py`

To get the modal fields and perform calculations on them we need to evaluate the fields
and perform the calculations with a coordinate object.

There are two types that come with *Polymode*, they are
 * `coordinate.PolarCoord`
 * `coordinate.CartesianCoord`

They are created with the parameters
 * `coordinates.PolarCoord`(rrange=(r,,min,,, r,,min,,), arange=(a,,min,,, a,,max,,), N=_number of points_, border=_border_)
 * `coordinates.CartesianCoord`(X=+/- x,,max,,, Y=+/- y,,max,,,, N=_number of points_)

The number of points can also be specified for both axes as N=(N,,r,,, N,,a,,) for polar and  N=(N,,x,,, N,,y,,) for cartesian objects. The _border_ option forces the nodes to not go to the full minimum and maximum r. This should usually be set to `border=1` to avoid a zero minimum r.

The most important member functions of the coordinate objects are `.polar2d()` and `.cartesian2d()`
which return a 2d array of radial and azimuthal and x and y locations respectively of the node points in
cartesian object.

Other useful member functions are:
 * `.grad_t(f)` calculates the 2d vector gradiant the scalar data f
 * `.div_t(A)` calculates the 2d divergence of the vector data A
 * `.curl_t(A)`  calculates the z-component of the transverse vector data A
 * `.int_dA(f)`  calculates the area integral of the scalar data f

In the tutorial file we create two coordinate objects one for polar and one cartesian. The border is set to 1 for polar coordinates so we avoid problems with division by zero at the origin.

{{{
res = 200

#Coordinate objects
c1 = coordinates.PolarCoord(rrange=(0,2), border=1, arange=(-pi,pi), N=(res/2,res))
c2 = coordinates.CartesianCoord(X=2, Y=2, N=res)
}}}

Now the cartesian node locations are obtained for each grid:
{{{
x1,y1 = c1.cartesian2d()
x2,y2 = c2.cartesian2d()
}}}

And they are plotted using the _scatter_ function.
{{{
#Plot the point distribution
subplot(221)
scatter(x1,y1, 2)
axis('tight')

subplot(222)
scatter(x2,y2, 2)
axis('tight')
}}}

We have a function that is defined in carteisan coordinates. This could be also defined in radial coordinates as well.
{{{
f = lambda x,y: y*exp(-2*(x**2 + y**2))
}}}

The div(grad(f)) scalar function is calculated in both coordinates, this should be the same! We then plot them both in different subplots using the `Plotter.plot_v(coord, f)` function
{{{
g1=c1.div_t(c1.grad_t(f(x1,y1)))
g2=c2.div_t(c2.grad_t(f(x2,y2)))

subplot(223)
Plotter.plot_v(c1,real(g1))
axis('tight')

subplot(224)
Plotter.plot_v(c2,real(g2))
axis('tight')
}}}

We evaluate the integral of the absolute value of _f_ again with both coordinates. They again should be equivalent.
{{{
print "Function integral on polar grid:", c1.int_dA(abs(f(x1,y1)))
print "Function integral on cartesian grid:", c2.int_dA(abs(f(x2,y2)))
}}}

http://polymode.googlecode.com/svn/wiki/figures/fig14_coordinates.png

=== Calculations with coordinates ===
This tutorial file is `ex6_calculating_with_coordinates.py`

Now most actions with modes can use coordinates. In particular we can plot what
the mode fields look like sampled on the points of the particular coordinate object
we have chosen simply by giving the `coord=` paramter to the plot command.
{{{
subplot(121)
m.plot(coord=c1)

subplot(122)
m.plot(coord=c2)
}}}

This plots the same mode on the polar and cartesian grids that we created in 
the previous tutorial. All the same options for the `.plot()` method that
have been available can be used. Try plotting the _x_ and _y_ components of the
electric and magnetic fields using both coordinates.

http://polymode.googlecode.com/svn/wiki/figures/fig15_coordinate_fields.png

Also we can use the coord objects as options when we calculate properties of
the mode, such as the group index.
{{{
print "The group index using polar coordinates:", m.group_index(wg, coord=c1).real
print "The group index using cartesian coordinates:", m.group_index(wg, coord=c2).real
}}}

Now let's calculate something using a coordinate object. Here we calculate the 
integral approximation to the propagation constant (Synder & Love, 1983, pg 222)

http://mathurl.com/?img=ceem4w&x.png
<wiki:comment>
\beta = Z_0 k \frac{ \int_A n^2 \mathbf{e} \times h^* \cdot \hat{z} dA}{ \int_A n^2 |\mathbf{e}|^2 dA}
</wiki:comment>

Where _Z₀_ is the impedance of free space. Note that througout the code the electric field is scaled by the impedence of free space, so we can take _Z₀_=1,

http://mathurl.com/?img=bjhgob&.png
<wiki:comment>
E = Z_0 E_\textrm{calculated}
</wiki:comment>

{{{
e = m.electric_field(wg, coord=c1)
exhz = m.ExHc_t(coord=c1)
e2 = sum(abs(e)**2,axis=0)

n2 = m145.index(wl)**2

beta = m.k0*c1.int_dA(n2*exhz)/c1.int_dA(n2*e2)
}}}

=== Retreiving mode fields ===

Now we can extract the electric and magnetic fields from the modes we can do a lot of calculation with them.

The fields are extracted using the methods
 * _mode_.magnetic_field(cartesian=True/False, coord=_coordinate object_)
 * _mode_.electric_field(wg=_waveguide_, cartesian=True/False, coord=_coordinate object_)

These return the magnetic field vector and the electric field vector respectively. The magnetic field vector
will be h=(h_x, h_y, h_z) if the coordinate object is cartesian or the cartesian option is given as true, and h=(h_r, h_ϕ, h_z) if a polar coordinate object is given, or if the cartesian option is given as false. This is similar for the electric field.

Note that the waveguide can be given to the electric field to aid the calculation of the logitudinal component of the electric field, e_z. If it is not given a constant refractive index is assumed throughout, which may or may not be a good approximation to the field depending on the location of the field intensity.

Similarly the transverse field components only can be extracted using the following matching methods

 * _mode_.magnetic_transverse_field(cartesian=True/False, coord=_coordinate object_)
 * _mode_.electric_transverse_field(cartesian=True/False, coord=_coordinate object_)

Following we use these commands to estimate the relative electric and magnetic fields in the _z_ direction,
relative to the transverse direction. We can use this to estimate if a mode is TM-like or TE-like.
{{{
hr,ha,hz = m.magnetic_field(coord=c1)
er,ea,ez = m.electric_field(wg, coord=c1)

print "TM like mode factor", sqrt(abs(hr)**2+abs(ha)**2).sum()/abs(hz).sum()
print "TE like mode factor", sqrt(abs(er)**2+abs(ea)**2).sum()/abs(ez).sum()
}}}

The same can be done for the cartesian coordinate, notice that in this case we are automatically returned the cartesian vector field.
{{{
h2 = m.magnetic_field(coord=c2)
e2 = m.electric_field(wg, coord=c2)
hx,hy,hz = h2
ex,ey,ez = e2
}}}

The Poynting vector is the cross product of the electric and conjugate magnetic fields, http://mathurl.com/?img=ao4vzb%.png
<wiki:comment>
S = \frac{1}{2} e \times h^*
</wiki:comment>

{{{
poynting = cross(e2,conj(h2), axis=0)

#The x-component of the poynting vector
subplot(131)
Plotter.plot_v(c2, poynting[0].real)
wg.plot(fill=0, boundary=0)

subplot(132)
Plotter.plot_v(c2, poynting[1].real)
wg.plot(fill=0, boundary=0)

subplot(133)
Plotter.plot_v(c2, poynting[2].real)
wg.plot(fill=0, boundary=0)
}}}

We plot the real part of the three components of the Poynting vector as usual.

http://polymode.googlecode.com/svn/wiki/figures/fig16_poynting.png

=== Degenerate modes ===
This tutorial file is `ex6_degenerate_modes.py`

As was mentioned earlier modes in fibers with a symmetry 3 or greater in mode classes m₀ ≠ 0 are degenerate.
The mode calculated by *Polymode* will be elliptic and the two degenerate modes can be calculated from one elliptically
polarized mode.

Of course in fibers that have rotational symmetry that is not exploited by the code (the symmetry=1 option is used in the waveguide) will still have degenerate modes however together they will not be able to be generated from a single calculated mode.

To construct a pair of orthogonal degenerate modes we use the two functions

 * Modes.construct_degenerate_pair(_mode_)
 * Modes.construct_lp_degenerate_pair(_mode_)
 
 Where `construct_degenerate_pair` constructs two circularly polarized modes and `Modes.construct_lp_degenerate_pair` constructs two linearly polarized modes.
 
{{{
mc1,mc2 = Modes.construct_degenerate_pair(modes[0])

m1,m2 = Modes.construct_lp_degenerate_pair(modes[0])

Plotter.plot_modes_in_grid([mc1,mc2,m1,m2], 'pe')
}}}

Run this example to plot the electric polarizations of the two mode pairs, and note that the circularly polarized modes are orthogonal - the arrows on the circles point in opposite directions.

http://polymode.googlecode.com/svn/wiki/figures/fig17_degenerate.png

----

== Tutorial 7 ==

 * Solvers
 * Compressing modes
 
== Tutorial 8 ==

 * Solving parallel jobs with MPI
 
 
